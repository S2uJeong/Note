# 📁 프로그래밍 언어 활용

### 01. 응용 SW 기초 기술 활용

### 📒 키워드 : UNIX, 배치 전략, 페이지 교체 알고리즘, 프로세스, 스레드, HRN, UNIX명령어, IPv6, OSI 참조모델, TCP

- UNIX / LINUX / MacOS
    - UNIX 특징
        - 다중 사용자, 다중 작업을 지원
        - 많은 네트워킹 기능을 제공하므로 통신망 관리용 운영체제로 적합하다.
    - UNIX 시스템의 구성요소
        - 하드웨어 > 커널 > 쉘 > 유틸리티 > 사용자
        - `쉘` - 명령어 해석, 사용자 인터페이스 vs `커널` - 유닉스 핵심, ~관리
    - 주기억장치
        - 레지스터 > 캐시 기억장치 > 주기억장치 > 보조기억장치
            - 왼쪽일수록 접근시간과 기억용량이 적다.
            - 보조기억장치에 있는 것은 CPU가 직접 액세스 할 수 없다.
        - 기억장치 관리 전략 : `반입 Fetch`, `배치 Placement`, `교체 Replacement`
            - 반입 전략 - 보조기억 장치에 보관중인걸 언제 주기억장치로 적재 하는지
            - 배치 전략 - 주기억장치의 어디에 위치시킬것인지
                - 단편화 현상을 신경써야 함.
                - 단편화 - 내부단편화 (저장될게 더 작아서 남는 용량), 외부단편화 (저장될게 더 커서 남는 용량의 합)
            - 교체 전략 - 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 데이터가 배치 하려고 할 때, 어느 영역과 교체해 사용할 것인지 결정

              `FIFO`, `OPT`, `LRU`, `LFU`, `NUR`, `SCR` 등이 있다.

              방법별로 페이지 부재의 수가 얼마나 생기는지가 문제로 자주 나옴

                - FIFO - 가장 오래 있었던 페이지를 교체
                - LRU (Least Recently Used) - 오랫동안 사용하지 않은
                - LFU (Least Frequently Used) - 사용 빈도가 적은
                - NUR (Not Used Recently) - 최근에 사용하지 않은, LRU 에서 나타나는 시간적인 오버헤드를 줄일 수 있다.

                  하드웨어 비트가 필요한 기법

                - SCR (Second Chance Replacement) - FIFO 기법 단점 보완
    - 가상기억장치
        - 보조기억장치(하드디스크)의 일부를 주기억장치처럼 사용하는 것
        - 프로그램을 블록 단위로 나누어서 가상기억장치에 보관해 놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리한다.
        - 구현방법
            - 페이징 기법 - 일정한 크기로 나눔, 내부단편화와 관련
            - 세그먼테이션 기법 - 불규칙 크기, 외부단편화, 기억공간 절약
        - 관리 사항
            - 페이지 크기
                - 페이지 크기가 작음

                  장점 :  페이지 단편화 감소, 주기억장치로 이동하는 시간 감소, 불필요한 내용 적재 확률 적어 효율적인 워킹셋, Locality에 더 일치할 수 있어 기억장치 효율 증가

                  단점 : 맵 테이블의 크기가 커지고 매핑속도가 늦어짐, 디스크 접근 횟수 증가 - 입출력 시간 증가

            - Locality
                - 시간 구역성 (Temporal Locality) - 프로세스 실행 시 하나의 페이지를 일정시간동안 집중적으로 액세스한다.
                    - 관련 기억 장소 : Loop, Stack, 부 프로그램 (Sub Routine) , Counting, 집계에 사용되는 변수
                - 공간 구역성 (Spatial Locality) - 일정 위치의 페이지 집중적으로
                    - 관련 기억 장소 : 배열순회, 순차적 코드의 실행, 프로그래머들이 관련된 변수
            - 워킹 셋
                - 자주 참조하는 페이지의 집합, Locality 특징을 이용한다.
                - 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 교체 현상을 줄임
            - 페이지 부재 빈도 방식
                - 페이지 부재율에 따라 주기억장치에 있는 페이지 프레임 수를 늘리거나 줄이는 것. 부재율이 높으면 페이지 수를 늘림
            - 프리페이징 PrePaging
                - 처음의 과도한 페이지 부재를 방지하기 위해 페이지를 한꺼번에 프레임에 적재하는 방법
            - 스래싱 Thrashing
                - 프로세스 처리 시간 < 페이지 교체 소요 시간 이 되는 현상
                - 다중프로그래밍의 정도가 높아지며 CPU 이용률이 높아지다가, 스레싱이 나타나면 CPU의 이용률이 급격히 감소한다.
                - 방지 방법 : 다중 프로그래밍의 정도 적정 수준으로, 페이지 부재 빈도 조절, 워킹셋 유지, 분석으로 임계치를 예상하여 운영
    - 프로세스
      - 개념
          - 프로세서(처리기, CPU)에 의하여 처리되는 프로그램, 실행중인 프로그램, 작업, 태스크
          - PCB를 가진 프로그램, 운영체제가 관리하는 실행 단위
      - PCB (Process Control Block) 프로세스 제어 블록
          - 운영체제가 프로세스에 대한 중요한 정보를 저장해 두는 곳
          - 각 프로세스가 생성될 때마다 고유의 PCB가 생성, 완료되면 제거함
      - 프로세스 상태 전이
          1. Submit 제출 - 작업을 처리 하기 위해 사용자가 작업을 시스템에 제출
          2. Hold  접수 - 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태
          3. Ready 준비- 프로세스가 프로세서를 할당 받기 위해 기다리고 있는 상태, 준비상태 큐에서 실행을 준비, 접수 → 준비로의 전이는 Job 스케줄러에 의해 수행됨

        4-1. Run 실행 - 프로세서 할당받아 실행되는 상태,

          1. 수행 완료 전 프로세서 할당 시간 종료되면 프로세스는 준비 상태로
          2. 실행 중에 입출력 처리가 필요하면 대기 상태로 전이

        4-2. Wait, Block 대기 - 입출력이 완료될 때까지 대기하고 있는 상태

        4-3. Terminated, Exit 종료 - 프로세스 실행이 끝나고 프로세스 할당이 해제된 상태

      - 프로세스 상태 전이 관련 용어
          - Dispatch - 준비 상태인 프로세스가 실행 상태로 전이되는 과정
          - Wake Up - 대기 상태가 준비상태로 되는 과정
          - Spooling -  입출력 한꺼번에 하기 위해 저장하는 과정, 접수상태에서 일어난다.
          - 교통량 제어기 (Traffic Controller) - 프로세스 상태에 대한 조사와 통보 담당
      - 스레드
          - 프로세스 내 작업단위, 경량 프로세스 라고도 함
          - 분류
              - 사용자 수준
                  - 커널 모드로의 전환이 없어 오버헤드 감소
                  - 속도 빠르지만 구현 어렵
              - 커널 수준
                  - 프로세스 대기 없어 시스템 성능 증가
                  - 여러 스레드가 커널에 동시 접근 가능
                  - 스레드의 독립적인 스케줄링 가능
          - 사용 장점
              - 병행성 증진, 응용프로그램의 응답시간 단축, 실행 환경을 공유시켜 기억장소의 낭비 감소, 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신
  - 스케줄링
      - 프로세스가 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에 할당하는 작업
      - 문맥교환 - 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생되는 것
      - 비선점 스케줄링 - FCFS=FIFO, SJF, 우선순위, HRN, 기한부 , 못 뺏음
          - FCFS (First Come First Service) - 준비상태 큐에 도착한 순서에 따라
          - SJF (Shortest Job First) - 실행시간이 제일 짧은거 우선, 가장 적은 평균 대기시간, 긴 프로세스는 무한 연기 상태 발생 가능성 있음
          - HRN (Hightest Respone-ratio Next) - 대기 시간과 실행 시산 모두 고려,
              - 계산식 = (대기시간+서비스시간)/ 서비스시간

                서비스 실행 시간이 짧거나, 대기 시간이 긴 프로세스가 우선순위

      - 선점 스케줄링 - Round Robin(RR), SRT, 선점 우선순위, 다단계 큐
  - 운영체제 기본 명령어
      - 유닉스/리눅스 기본 명령어
          - `fork` - 새로운 프로세스를 생성 (하위 프로세스 호출, 프로세스 복제)
          - `uname` - 시스템의 이름과 버전, 네트워크 호스트명 등의 시스템 정보 표시
  - 인터넷
      - IP 주소
          - 숫자로 8비트씩 4부분, 총 32비트
              - A class - 국가나 대형 통신망 (0~127),  2^24 호스트 사용
              - B class - 중대형 통신망 (128~191), 2^16
              - C class - 소규모 (192 ~ 223) , 2^8
              - D class - 멀티캐스트용 (224 ~ 239)
      - 서브네팅 Subnetting
      - IPv6
          - IPv4와 IPv6 간의 주소 전환에 사용 되는 기능 : 듀얼 스택, 헤더 변환, 터널링 (오답 : 라우팅)
          - 128비트의 긴 주소 사용, 자료 전송 속도 빠름
          - 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제 해결
          - 확장성이 뛰어나며 실시간 흐름 제어로 향상된 멀티미디어 기능
          - 패킷 크기 확장 가능, 기본 헤더 뒤에 확장 헤더를 더해 네크워크 기능 확장이 용이, 패킷 헤더는 40Byte 고정길이
          - 자동으로 네트워크 환경 구성 가능 (주소 자동설정)

        구성

          - 총 128비트, 콜론(:)으로 구분
          - 유니캐스트 : 1대1 통신
          - 멀티캐스트 : 1대 다 통신
          - 애니캐스트 : 단일 송신자와 가장 가까이 있는 단일 수신자와 1대1통
  - OSI 참조 모델
      - 하위 계층 : 물리 → 데이터 링크 → 네트워크 →
      - 상위 계층 : 전송 → 세션 → 표현 → 응용 계층
      1. 물리계층 Physical Layer
          - 전송에 필요한 두 장치간에 실제 접속, 물리적 전송 매체와 전송 신호 방식 정의
          - 리피터, 허브
      2. 데이터 링크 계층
          - 흐름 제어, 프레임 동기화, 오류 제어, 순서 제어
          - 랜카드, 브리지, 스위치
      3. 네트워크/망 계층
          - 네트워크 연결,유지,해제, 패킷 전달, 경로 설정(라우팅), 트래픽제어
          - 라우터
      4. 전송 계층 Transport Layer
          - 상위/하위 계층의 인터페이스 담당, 단말기 사이의 오류수정  전송 연결 설정, 주소 설정, 다중화
          - TCP, UDP, 게이트웨이
      - 세션 계층
          - 송수신간의 관련성 유지, 대화 제어, 전송 정보의 일정한 부분에 체크점을 두어 수신 상태 체크, 체크점을 동기점이라고 한다. 이 점은 데이터 회복에 쓰임
  - 네트워크 관련 장비
      - 브리지 - 트래픽 병목 현상 감소시킴, 네트워크 분산
      - 스위치 - LAN 과 LAN을 연결
      - 라우터 - 데이터 전송의 최적경로
      - 브라우터 - 브리지 + 라우터
      - 전처리기 FEP Front End Processor - 통신 검사 등을 미리 수행하여 컴퓨터의 부담을 줄여줌

## 02. 프로그래밍 언어
### 📒키워드 : 변수명 작성 규칙, 연산자, printf, 다중 if문, for문, while문, 배열, 포인터, 구조체, C언어의 라이브러리

### **01. 변수**

- 종류
    - 자동변수 auto : 메모리(스택)/일시적/지역적 , 초기화 안하면 쓰레기값이 저장된다.
    - 외부변수 extern : 함수가 종료된 뒤에도 값이 소멸하지 않음, 초기화 안하면 0으로 자동 초기화
    - 정적변수 static :	내부/외부 정적변수로 나뉨, 두 변수 모두 함수가 종료되도 소멸하지 않음. 초기화는 변수 선언 시 한번만 가능하며 생략하면 자동으로 0으로 초기화
    - 레지스터변수 register : 레지스터 용량 부족하면 자동변수도 취급됨, 메모리 주소를 가지지 않아 주소를 구하는 연산자 사용불가

### **02. 데이터 입출력**

**scanf, scanner**

---

- scan(서식문자열, 변수의 주소)
    - 변수 주소 : {&변수}
    - 배열명은 그 자체로 주소를 나타내므로 `&` 를 붙이지 않는다.

    ```c
    printf("%d %f",&i,&j); 
    ```

- %d, o, x : 정수형 10,8,16진수

  %ld,lo,lx : lonn형 “

  %c, s: 문자, 문자열

  %f : 실수형

- Scanner

    ```java
    Scanner sc = new Scanner(System.in);
    int num = sc.nextInt();
    ```

    - nextLine() : 라인 전체를 문자열로 반환
    - nextFloat()
- 오답노트

    ```java
    // 1. 소수점을 포함하여 앞에 4자리
    scanf("%4f", &i)   // 12.123
    // out : 12.1  
    
    // 2. 공백이 있으면 공백 앞까지만 문자열
    char b[8];
    scanf("%s", b) // GIL BUT
    // out : GIL 
    
    // 3. scanf의 같은 명령줄에 들어간 변수는 내용을 공유한다. 
    char b[8], c[8];
    scanf("%c %5c", b,c); // LOVE ME
    // out : b = L , c = OVE M
    
    // 4. 각각 변수는 자신의 형식에 맞는 데이터만 담는다.
    // 5. 실수형에 정수를 담으면 .0으로 저장되지 않고 그냥 정수로 저장된다. 
    
    // 6. 형식에 특정 문자를 기준화할 수 있다.
    scanf("%3d$$%3f",&i,&j);  // 123$$456789
    	// out : i = 123 , j = 456 , 입력한 데이터에 $$가 없으면 정상적 입력 불가.
    ```


**printf**

---

- `scanf`와 달리 주소연산자를 붙이지 않는다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5b9fa27b-e5d4-4719-b420-56e744ab8954/5cc8e934-e4c1-4f75-95ac-d8a614b47a44/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5b9fa27b-e5d4-4719-b420-56e744ab8954/869da3f3-69a1-4e7c-8e86-ef7ca5f3a9c8/Untitled.png)

1. `%n`출력할 값이 지정한 자릿수보다 큰 경우 자릿수를 무시하고 모두 출력 (소수점 숫자 말고, 정수형 조건일때)
2. VV2543
    1. 기본 오른쪽부터 출력, `-` 붙으면 왼쪽부터 출력
    2.      VVnnnnn ,            nnnnnVV
3.  245.2555

→ 245.255500 — `%f`  소숫점 부분 기본값 6자리 출력

1. 245.255 → 245.256
    1. 소숫점 이하  반올림해서 버린다.
2. vvvvv245.25
    - `%nf`  : **소수점까지** 전체 자릿수, `%.nf` : 소수점 자리만
3. `.3s` - 왼쪽을 기준으로 3글자만 출력  help me ⇒ hel
4. `%8.6s` VVhelp m
5. `%-8.6s` helo mVV
6. 입력 : `scanf(”%2d %3d", &i, &j)` 12345678

   출력 : `printf("%d %d",i,j)`

   (i)12 (j)345

   🔴 주의점 : print시엔 자릿수 무시하고 다 출력하지만, 입력시에는 표시된 숫자만큼만 입력 받으므로 헷갈리지 말것

   내 오답 : (i) 12345678 (j) 12345678


**기타 입출력**

---

- 입력
    1. a = `getchar()` : 키보드로 한 문자를 입력
    2. `gets(a)` : 키보드로 문자열 입력 , enter 기준으로 문자열 하나로 인식
- 출력
    1. `putchar(a)` : 인수로 주어진 한 문자 출력
    2. `puts(a)` : 인수로 주어진 문자열 출력뒤 커서 다음 줄로 이동

  ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5b9fa27b-e5d4-4719-b420-56e744ab8954/01de8af3-ca5c-485d-9f2d-92896b6efab2/Untitled.png)


### 03. 반복문

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5b9fa27b-e5d4-4719-b420-56e744ab8954/2ccad261-d684-4aab-8242-bb318e8b41eb/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5b9fa27b-e5d4-4719-b420-56e744ab8954/2f664357-8209-4eb2-9fef-a6d6440d5428/Untitled.png)

### 04. 배열과 문자열

- C언어에서 배열 위치를 나타내는 첨자 없이 배열 이름을 사용하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같다.
- 배얼의 개수보다 적은 수로 배열을 초기화하면 나머지 요소에는 0이 입력된다. (int 배열일 경우)
- C언어에는 문자열을 저장하는 자료형이 없기 때문에 배열 또는 포인터를 이용하여 처리한다.

    ```c
    char arr[] = "문자열입니다."
    chhar arangeArr[5] = "love"   // love/0 으로 5개의 배열이 생성됨. 
    ```

    - 이 경우, 문자열의 끝을 알리기 위한 널 문자 `/0` 가 문자열 끝에 자동으로 삽입. → 따라서 고려하여 배열크기를 저장해야 한다.
    - 이미 선언된 배열에는 문자열을 저장할 수 없어, 선언 시 꼭 초기화 해주어야 한다.
- `strcat(s,s)` : 앞 문자열에 뒤 문자열을 붙이는 함수
- 아스키코드
    - {65:A} , {97:a}
    - char형 변수에는 int가 저장된다.

### 05. 포인터

- {포인터 : 변수의 주소}, {포인터변수 : 변수의 주소를 저장할 때 사용하는 변수}
- 포인터변수는 동적 메모리 영역인 Heap 영역에 접근하는 동적 변수이다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5b9fa27b-e5d4-4719-b420-56e744ab8954/877cceb8-5e58-41f2-92d7-72f9208a4401/Untitled.png)

- `*`
    - 선언할 때 - 이 변수가 포인터 변수임을 의미
    - 아닐 때 - 그 포인터변수가 가리키는 곳의 ‘값’을 의미
- 포인터변수
    - `*` 있을 때 - 값을 가짐
    - 없을 때 - 주소를 가짐 → `&`다른변수

```c
int *b; int a;

b = &a;  // 주소를 담는건 데이터형을 지정해 줄 수 없으니까.
*b = a;

main() {
 int a = 50; int *b;
 b = &a;  // 배열일 때는, &안 붙여도 된다. 인덱싱 안 해주면 arr[0]부터 탐색 
 *b = *b + 20;
// out : a = 70, *b = 70
}
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5b9fa27b-e5d4-4719-b420-56e744ab8954/6f1df5e0-43d3-4e90-8bee-94e116c06680/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5b9fa27b-e5d4-4719-b420-56e744ab8954/ae2c4f8c-50b1-4088-8f8b-1ac4382f01b0/Untitled.png)

### 06. 구조체

- 배열이 자료의 형과 크기가 동일한 변수의 모임이라면, 구조체는 자료의 종류가 다른 변수의 모임이다.
- 예약어는 `struct` (약간 자바의 class 느낌)

```c

// 구조체 선언
struct member {
	char name[10];
  int pay;
};

// 구조체 변수 선언
struct member member1, *mp;

// 구조체 멤버의 지정
	// 방법1 (.)
member1.name = "최수정";
member1.pay = 9000000;
	// 방법2 (->)
mp -> name = "최수정";
	// 방법3 (*포인터변수)
(*mp).name = "최수정";
(*member1).pay = 900000;
```

### 07.  파이썬

- 클래스

    ```python
    class 클래스명:
    	 실행할 문장
      def 메소드명 (self, 인수) : # 메소드에서 자기 클래스에 속한 변수에 접근할 때 사용하는 명칭 
    			return 
    ```