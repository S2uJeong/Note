# 함수형 코딩 - 에릭 노먼드

## **1. 개요**

- 액션, 결과, 데이터를 잘 구분하는 것이 첫번째.
    - 코드를 데이터와 계산으로 바꿀 수록 분산 시스템에서 생기는 여러가지 문제를 해결 할 수 있다.
    - 결과적으로 액션에서 계산으로 코드를 옮기면 액션도 다루기 쉬워 진다.
- 일급 추상

## **2. 현실에서의 함수형 사고**

### **계층화 설계**

### **분산시스템의 타임 라인**

- 서로 다른 타임라인에 있는 액션 간 실행 순서는 보장할 수 없다. 따라서 타임라인을 서로 맞추지 않은 분산 시스템은 예측 불가능한 순서로 실행된다.
- 타임 라인 커팅 기술을 통해 타임라인이 동시에 진행 될 때 서로 순차적 순서를 맞출 수 있다.

## **3. 액션과 계산, 데이터의 차이**

```
액션 : 호출 횟수와 시점에 의존하는 것
계산 : 어떤 것을 결정하거나 계획 하는 것, 실행해도 다른 곳에 영향을 주지 앟음
데이터 : 어떤 이벤트에 대한 결과, 데이터 
```

## **4. 액션에서 계산 빼내기**

- 해당 과정을 통해 코드의 재사용성을 높이고 테스트를 용이하게 할 수 있다.

### **함수 입출력과 액션**

- 함수(액션)를 구성 하는 것 : 입력/출력,암묵/명시
    - 명시적 입력 : 함수의 인자
    - 명시적 출력 : return
    - 암묵적 입력 : 전역 변수 읽기
    - 암묵적 출력 : 전역 변수 값 변경, 콘솔 출력
- 함수에 암묵적 입/출력이 있으면 액션이 된다.

### **계산 빼내는 기술, 단계**

```
1. 계산 코드를 찾아 빼내 새로운 함수를 만들어 리팩토링
2. 새 함수에 암묵적 입력과 출력을 찾는다.
3. 암묵적 입력은 인자로, 암묵적 출력은 리턴값으로 바꾼다.
```

- 전역 배열을 바꾸는 암묵적 출력을 계산으로 바꾸기 위해, 카피-온-라이트 방법을 사용할 수 있다.
    - 계산 함수 호출 시, 전역 배열을 인자로 입력 받고, 이 전역 배열을 복사하여 계산 함수안에 지역 변수로 만든 뒤, 그 지역 변수로 배열을 변경하고 변경된 배열을 반환하여 처리한다.

## **5. 더 좋은 액션 만들기**

- 액션을 다 없앨 순 없다. 액션에서 암묵적 입력과 출력을 줄여 설계를 개선하는 방법을 알아보자
- 데이터 구조를 몰라도 실행 할 수 있어야 한다.
    - 함수의 목적에 맞는 인자와 출력을 갖출 것
- 대상에 따라 동작을 분리 한다.
    - 각 도메인, 기술 객체, 비즈니스 규칙 별로 구분하고, 한 함수에 하나의 대상만이 사용되도록 분리

## **6. 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기 :** 카피-온-라이트

- 데이터가 바뀌지 않아야 하는 이유
    - 변경 가능한 데이터를 읽는 것은 액션이고, 변경 불가능한 데이터를 읽는 것은 계산이기 때문이다.
    - 쓰기(변경)은 데이터를 변경 가능한 구조로 만드므로 데이터에 쓰기를 없애는 방법을 취해보자.

### 카피-온-라이트 :  동작을 불변형으로 만들기

- 대상 동작 예시
    - 제품 개수 가져오기 [읽기]
    - 제품 이름으로 제품 가져오기 [읽기]
    - 제품 추가하기 [쓰기]
    - 제품 이름으로 제품 구매 수량 바꾸기 [쓰기]
    - 가격 설정하기 [쓰기]
    - 가격 가져오기 [읽기]
- 과정
    1. 동작을 읽기, 쓰기, 또는 둘다로 분류
        - 읽기 : 데이터에서 정보 가져오기, 데이터를 바꾸지 않음
        - 쓰기 : 데이터를 바꿈
    2. 쓰기는 카피-온-라이트 적용 (쓰기를 읽기로 바꾸는 과정)
    3. 둘 다는 읽기 + 쓰기로 각각 분리하거나, 함수에서 값을 두개 리턴하도록 수정
    4. 중첩된 데이터 구조는 최하위부터 최상위까지 중첩된 데이터 구조의 모든 부분이 불변형이도록 차근차근 변경해준다.
        - 중첩된 데이터의 일부를 바꾸려면 변경하려는 값과 상위의 모든 값을 복사해야 한다.

- 카피-온-라이트 예시

    ```jsx
    // 배열에 대한 카피-온-라이트
    function add_element_last(array, elem) {
        var new_array = array.slice();   // 1. 복사본 만들기
        new_array.push(elem);            // 2. 복사본 바꾸기 (의도에 맞게)
        return new_array;                // 3. 복사본 리턴 
    }
    
    // 객체에 대한 카피-온-라이트
     function setPrice(item, new_price) {
        var item_copy = Object.assign({}, item);
        item_copy.price = new_price;
        return item_copy;
    }
    
    // 중첩된 데이터 구조에 대한 카피-온-라이트 
    
    function setPriceByName(cart, name, price) {
        var cartCopy = cart.slice();
        for(var i=0; i <cartCopy.length(); i++) {
            if(cartCopy[i].name === name) {
                cartCopy[i] = setPrice(cartCopy[i], price);
            }
        }
        return cartCopy;
    }
    
    function setPrice(item, new_price) {
        var item_copy = Object.assign({}, item);
        item_copy.price = new_price;
        return item_copy;
    }
    ```


### 불변 데이터 구조 효율성 고민

- 일반적으로 불변 데이터 구조는 변경 가능한 데이터 구조보다 메모리를 더 많이 쓰고 느리다.  값이 바뀔 때마다 복사를 하기 때문
- 하지만 일반 애플리케이션에서 쓰기 충분히 빠르다는 논점임. 아래는 그 이유이다.
    1. 언제든 최적화 가능 : 우선 써보고, 속도가 느리다면 최적화를 한다.
    2. 빠른 가비지 콜렉터
    3. 얉은 복사를 사용하기 때문에 생각보다 많은 성능을 요구하지 않는다.
        - 얕은 복사 : 중첩된 데이터 구조에 최상위 데이터만 복사.

          예를 들어, 객체가 들어 있는 배열을 복사한다면, 배열만 복사하고 안에 있는 객체는 참조로 공유한다.

    4. 함수형 프로그래밍 언어에는 빠른 구현체가 있다.
        - 데이터 구조를 복사할 때 최대한 많은 구조를 공유해서 더 적은 메모리를 사용하게 함
        -

## 7. 레거시 코드에서 불변성 지키기 : 방어적 복사

- 기존에 있던 불변성을 지키지 않은 레거시 코드를 통해 불변성을 추구해야 할 때
- 라이브러리나 모듈화를 통해 외부 통신해야 하는 경우 사용

### 카피-온-라이트와 방어적 복사 비교

- 카피-온-라이트 패턴은 데이터를 바꾸기 전에 복사하며, 무엇이 바뀌는지 알기 때문에 무엇을 복사해야 할지 예상할 수 있다.
- 하지만 레거시 코드는 정확히 예상할 수 없는 경우가 많다. 따라서 데이터가 바뀌는 것을 완벽히 막아주는 원칙이 필요하며 이를 방어적 복사라고 한다.

### 방어적 복사는 원본이 바뀌는 것을 막아준다.

- 깊은 복사본을 만들어 복사본으로 인자를 호출하고, 결과도 복사본으로 받는 방식
- 이 법은 인자로 들어온 값이 변경될 수도 있는 함수를 사용하면서 불변성을 지킬 수 있다.
- 방어적 복사 규칙
    1. 데이터가 안전한 코드에서 나갈 때 복사하기
    2. 안전한 코드로 데이터가 들어올 때 복사하기

```jsx
// 안전한 코드 (불변성이 지켜진 코드)
function add_item_to_cart(name, price) {
    //...
    // 1. 들어올 때 복사
    var cart_copy = deepCopy(shopping_cart); // shopping_cart 는 전역변수임
    // 불변성이 지켜졌는지 모를 함수 promotion()
    promotion(cart_copy);  
    // 3. 나갈 때도 복사
    shopping_cart = deepCopy(cart_copy);
}
```