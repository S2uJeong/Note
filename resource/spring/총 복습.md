# 01_스프링 입문
### MVC
- 컨트롤러가 정적 파일보다 우선순위가 높다.

- @ResponseBody를 사용하면 뷰 리졸버를 사용하지 않는다.
  - 대신에 HTTP의 바디에 내용을 직접 반환 
    - 문자 처리 : StringHttpMessageConverter
    - 객체 처리 : MappingJackson2~ (json으로 반환)
### Spring 
- 컴포넌트 스캔과 자동 의존관계 설정
  - 생성자 방식은 private final 키워드를 쓸 수 있게 하며
  - 의존관계가 실행중에 변하는 경우는 거의 없으므로 해당 방식 권장 
```java
@Controller 
public class MemberController {
    private final MemberService memberService;
    
    @Autowired
    public MemberController(MemberService memberService) {
        this.memberService = memberService;
    }
}
```
- 스프링은 스프링 컨테이너에 스프링 빈을 등록할 때 기본으로 싱글톤으로 등록한다. 그리고 공유한다. 
- 따라서 같은 스프링 빈이면 모두 같은 인스턴스 이다. 

### Data
- 스프링부트는 데이터베이스 정보를 바탕으로 DataSource를 생성하도 스프링 빈으로 만들어 둔다. 그래서 DI를 받을 수 있다.
- 순수 JDBC -> springBoot DataSource 이용하여 Connection획득 및 트랜잭션 관리(@Transactional) -> JdbcTemplate 이용
  - JPA
    - SQL도 만들어준다.
    - SQL과 데이터 중심의 설계에서 객체중심 설계로 패러다임 전환 가능 
    - Entity manager
      ```xml
          spring.jpa.show-sql=true  // 생성된 SQL출력 
          spring.jpa.hibernate.ddl-auto=none    // 테이블 자동 생성 기능 off -> on은 create모드
      ```
    - JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행할 것 (조회 같은 변경이 없는것은 예외)
    - JDBC보다 스키마 변경에 유연하게 대응 가능
    - ORM (객체-관계 매핑) 관련 세부기능
      - @Entity: JPA 엔티티 클래스를 나타내는 어노테이션입니다. 데이터베이스 테이블과 매핑됩니다.
      - @Table: 엔티티 클래스와 매핑되는 테이블을 지정하는 어노테이션입니다. 엔티티 클래스 이름과 테이블 이름이 다를 경우 사용됩니다.
      - @Id: 엔티티 클래스의 기본 키를 지정하는 어노테이션입니다.
      - @GeneratedValue: 기본 키의 값을 자동으로 생성하는 전략을 지정하는 어노테이션입니다.
      - @Column: 엔티티 클래스의 필드와 데이터베이스 칼럼을 매핑하는 어노테이션입니다.
      - @OneToMany, @ManyToOne, @OneToOne, @ManyToMany: 객체 간의 관계를 표현하는 어노테이션입니다.
        - @JoinColumn 어노테이션을 사용하여 데이터베이스에서 외래 키를 지정
  - 스프링 데이터 JPA
    - 인터페이스를 통한 기본적인 CRUD -> 메서드 이름만으로 다양한 쿼리 기능 제공
    - 페이징 기능 자동 제공
    - 복잡한 동적 쿼리는 Querydsl 이나 JPA가 제공하는 네이티브 쿼리 사용 아니면 JdbcTemplate를 사용한다. 

### AOP
- 공통 관심 사항과 핵심 관심 사항의 분리 
- @Aspect
- 공통되고 반복적으로 발생하는 관심사(로깅, 보안, 트랜잭션 관리 등)를 캡슐화한 모듈

# 02_스프링 핵심 원리 
- 스프링 없이 자바로 DI컨테이너 제작 - AppConfig를 이용해 조립 
## DI 컨테이너 
### 생성 과정
  - ApplicationContext 를 스프링컨테이너라 한다. 
    ```java
    ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
    ```
  - 스프링 컨테이너는 XML을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 스프링 컨테이너를 만든 것
  - <interface> BeanFactory <- <interface> ApplicationContext <--(BeanDefinition)--- AnnotationConflg/ApplicationConfig/xml
    - BeanFactory : 빈 관리, 조회에 관련한 메서드
    - ApplicationContext : +부가기능 (국제화기능, 환경변수, 애플리케이션이벤트, 편리한 리소스관리)
### 싱글톤 컨테이너 
- 요청마다 객체가 생성된다면 메모리 낭비가 심하므로 1개만 생성해서 공유하도록 한다. 
  - private 생성자를 이용해서 외부에서 임의로 new키워드를 사용하지 못하도록 막는다.
  - 이를 스프링 컨테이너 없이 패턴으로 구현한다면 객체지향 설계를 위반하게 되는 등 문제가 발생
- 싱글톤 주의점
  - 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.
    - 특정 클라이언트에 의존적인 필드가 있으면 안됨
    - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된
    - 가급적 읽기만 가능해야 함.
    - 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, TreadLocal등을 사용 
### 스프링 컨테이너가 싱글톤을 유지하는 방법
- 바이트코드 조작 , 스프링 설정 정보 - @Configuration
- 스프링이 CGLIB 라는 바이트조작 라이브러리를 사용해서 개발자가 제작한 클래스를 상속받은 임의의 다른 클래스를 만들고, 그 클래스를 스프링 빈으로 등록한다.
  - CGLIB 내부 로직은 스프링 컨테이너에 해당 클래스의 bean이 있으면 생성 말고 조회 및 반환을 하게 되어 있음 
- @Bean만 사용시 스프링 빈으로 등록은 되지만 싱글톤을 보장하지 않는다. 
  

## 컴포넌트 스캔
- @Component
- Config파일에 구구절절 빈 등록하는 코드 없이 스프링빈을 등록할 수 있다. 
  - Config파일의 클래스 상단에 @Configuration, @ComponentScan 달아줘야함. 
    - ComponentScan에서 탐색 위치를 지정할 수 있다. 
      ```java
      @ComponentScan(
         basePackages = {"hello.core"}
      )
        ```
    - 위 방법보다는 설정정보 클래스의 위치를 프로젝트 최상단에 두는것을 추천
    - @SpringBootApplication 안에 @ComponentScan이 들어 있다. 

## 의존관계주입
- @Autowired
  - @Autowired은 ApplicationContext.getBeam() 처럼 타입매핑을 우선 시도한다.
  - 이때 해당 타입에 두개 이상의 bean이 조회된다면, 컴파일 에러가 발생한다. 
  - 이때, 같은 인터페이스의 구현체라도, bean명을 달리 설정해준다면 @Autowired는 타입 매핑 후 필드명이나 파라미터 이름으로 추가 매칭하므로 구분이 가능하다.
  ```java
    // 필드명 차별화 전 (오류 발생 가능성 있음)
    @Autowired
    private DiscountPolicy discountPolicy
    // 필드 선언시 구체화 클래스의 이름으로 선언
    @Autowired
    private DiscountPolicy rateDiscountPolicy
  ```
  - @Qualifier,@Primary를 이용해 구분하는 방법도 있다. 
    - 둘 중엔 @Qualifier가 우선권이 높다. 

### 조회한 빈이 모두 필요할 때
- 할인 서비스를 제공하는데 클라이언트가 할인의 종류를 선택할 수 있다고 가정했을 때.
- Map, List와 같은 자료구조에 담아 의존관계를 주입할 수 있다.

### 수동/자동 등록
- 기술 지원 같은 AOP 관련 클래스는 수동 등록 권장
- 할인정책과 같이 다형성을 적극 활용하는 비즈니스 로직도 수동 등록 고민
- 나머지 업무 로직은 자동기능을 통해 편리하게 사용해도 될것 같음

