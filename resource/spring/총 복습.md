# 01_스프링 입문
### MVC
- 컨트롤러가 정적 파일보다 우선순위가 높다.

- @ResponseBody를 사용하면 뷰 리졸버를 사용하지 않는다.
  - 대신에 HTTP의 바디에 내용을 직접 반환 
    - 문자 처리 : StringHttpMessageConverter
    - 객체 처리 : MappingJackson2~ (json으로 반환)
### Spring 
- 컴포넌트 스캔과 자동 의존관계 설정
  - 생성자 방식은 private final 키워드를 쓸 수 있게 하며
  - 의존관계가 실행중에 변하는 경우는 거의 없으므로 해당 방식 권장 
```java
@Controller 
public class MemberController {
    private final MemberService memberService;
    
    @Autowired
    public MemberController(MemberService memberService) {
        this.memberService = memberService;
    }
}
```
- 스프링은 스프링 컨테이너에 스프링 빈을 등록할 때 기본으로 싱글톤으로 등록한다. 그리고 공유한다. 
- 따라서 같은 스프링 빈이면 모두 같은 인스턴스 이다. 

### Data
- 스프링부트는 데이터베이스 정보를 바탕으로 DataSource를 생성하도 스프링 빈으로 만들어 둔다. 그래서 DI를 받을 수 있다.
- 순수 JDBC -> springBoot DataSource 이용하여 Connection획득 및 트랜잭션 관리(@Transactional) -> JdbcTemplate 이용
  - JPA
    - SQL도 만들어준다.
    - SQL과 데이터 중심의 설계에서 객체중심 설계로 패러다임 전환 가능 
    - Entity manager
      ```xml
          spring.jpa.show-sql=true  // 생성된 SQL출력 
          spring.jpa.hibernate.ddl-auto=none    // 테이블 자동 생성 기능 off -> on은 create모드
      ```
    - JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행할 것 (조회 같은 변경이 없는것은 예외)
    - JDBC보다 스키마 변경에 유연하게 대응 가능
    - ORM (객체-관계 매핑) 관련 세부기능
      - @Entity: JPA 엔티티 클래스를 나타내는 어노테이션입니다. 데이터베이스 테이블과 매핑됩니다.
      - @Table: 엔티티 클래스와 매핑되는 테이블을 지정하는 어노테이션입니다. 엔티티 클래스 이름과 테이블 이름이 다를 경우 사용됩니다.
      - @Id: 엔티티 클래스의 기본 키를 지정하는 어노테이션입니다.
      - @GeneratedValue: 기본 키의 값을 자동으로 생성하는 전략을 지정하는 어노테이션입니다.
      - @Column: 엔티티 클래스의 필드와 데이터베이스 칼럼을 매핑하는 어노테이션입니다.
      - @OneToMany, @ManyToOne, @OneToOne, @ManyToMany: 객체 간의 관계를 표현하는 어노테이션입니다.
        - @JoinColumn 어노테이션을 사용하여 데이터베이스에서 외래 키를 지정
  - 스프링 데이터 JPA
    - 인터페이스를 통한 기본적인 CRUD -> 메서드 이름만으로 다양한 쿼리 기능 제공
    - 페이징 기능 자동 제공
    - 복잡한 동적 쿼리는 Querydsl 이나 JPA가 제공하는 네이티브 쿼리 사용 아니면 JdbcTemplate를 사용한다. 

### AOP
- 공통 관심 사항과 핵심 관심 사항의 분리 
- @Aspect
- 공통되고 반복적으로 발생하는 관심사(로깅, 보안, 트랜잭션 관리 등)를 캡슐화한 모듈

# 02_스프링 핵심 원리 
- 스프링 없이 자바로 DI컨테이너 제작 - AppConfig를 이용해 조립 
## DI 컨테이너 
### 생성 과정
  - ApplicationContext 를 스프링컨테이너라 한다. 
    ```java
    ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
    ```
  - 스프링 컨테이너는 XML을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 스프링 컨테이너를 만든 것
  - <interface> BeanFactory <- <interface> ApplicationContext <--(BeanDefinition)--- AnnotationConflg/ApplicationConfig/xml
    - BeanFactory : 빈 관리, 조회에 관련한 메서드
    - ApplicationContext : +부가기능 (국제화기능, 환경변수, 애플리케이션이벤트, 편리한 리소스관리)
### 싱글톤 컨테이너 
- 요청마다 객체가 생성된다면 메모리 낭비가 심하므로 1개만 생성해서 공유하도록 한다. 
  - private 생성자를 이용해서 외부에서 임의로 new키워드를 사용하지 못하도록 막는다.
  - 이를 스프링 컨테이너 없이 패턴으로 구현한다면 객체지향 설계를 위반하게 되는 등 문제가 발생
- 싱글톤 주의점
  - 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다.
    - 특정 클라이언트에 의존적인 필드가 있으면 안됨
    - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된
    - 가급적 읽기만 가능해야 함.
    - 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, TreadLocal등을 사용 
### 스프링 컨테이너가 싱글톤을 유지하는 방법
- 바이트코드 조작 , 스프링 설정 정보 - @Configuration
- 스프링이 CGLIB 라는 바이트조작 라이브러리를 사용해서 개발자가 제작한 클래스를 상속받은 임의의 다른 클래스를 만들고, 그 클래스를 스프링 빈으로 등록한다.
  - CGLIB 내부 로직은 스프링 컨테이너에 해당 클래스의 bean이 있으면 생성 말고 조회 및 반환을 하게 되어 있음 
- @Bean만 사용시 스프링 빈으로 등록은 되지만 싱글톤을 보장하지 않는다. 
  

## 컴포넌트 스캔
- @Component
- Config파일에 구구절절 빈 등록하는 코드 없이 스프링빈을 등록할 수 있다. 
  - Config파일의 클래스 상단에 @Configuration, @ComponentScan 달아줘야함. 
    - ComponentScan에서 탐색 위치를 지정할 수 있다. 
      ```java
      @ComponentScan(
         basePackages = {"hello.core"}
      )
        ```
    - 위 방법보다는 설정정보 클래스의 위치를 프로젝트 최상단에 두는것을 추천
    - @SpringBootApplication 안에 @ComponentScan이 들어 있다. 

## 의존관계주입
- @Autowired
  - @Autowired은 ApplicationContext.getBeam() 처럼 타입매핑을 우선 시도한다.
  - 이때 해당 타입에 두개 이상의 bean이 조회된다면, 컴파일 에러가 발생한다. 
  - 이때, 같은 인터페이스의 구현체라도, bean명을 달리 설정해준다면 @Autowired는 타입 매핑 후 필드명이나 파라미터 이름으로 추가 매칭하므로 구분이 가능하다.
  ```java
    // 필드명 차별화 전 (오류 발생 가능성 있음)
    @Autowired
    private DiscountPolicy discountPolicy
    // 필드 선언시 구체화 클래스의 이름으로 선언
    @Autowired
    private DiscountPolicy rateDiscountPolicy
  ```
  - @Qualifier,@Primary를 이용해 구분하는 방법도 있다. 
    - 둘 중엔 @Qualifier가 우선권이 높다. 

### 조회한 빈이 모두 필요할 때
- 할인 서비스를 제공하는데 클라이언트가 할인의 종류를 선택할 수 있다고 가정했을 때.
- Map, List와 같은 자료구조에 담아 의존관계를 주입할 수 있다.

### 수동/자동 등록
- 기술 지원 같은 AOP 관련 클래스는 수동 등록 권장
- 할인정책과 같이 다형성을 적극 활용하는 비즈니스 로직도 수동 등록 고민
- 나머지 업무 로직은 자동기능을 통해 편리하게 사용해도 될것 같음

## 빈 생명주기 콜백
- 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 종료 시점에 연결을 모두 종료하는 작업을 진행하려면 객체의 초기화, 종료 작업이 중요함
- 활용 업무 
  - 데이터베이스 초기화 
  - 자원 해제 : 메모리 누구, 자원 누수 방지 (데이터베이스, 파일 시스템 리소스)
  - 캐시 초기화 및 정리 : 애플리케이션 성능 향상 가능
  - 외부 서비스 초기화 및 종료 : 메시징 브로커, 웹 소켓 서버와의 연결 설정 및 해제 
  - 스케줄링 작업 관리 
- 스프링 빈의 이벤트 라이프사이클 
  - 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸 전 콜백 -> 스프링종료
- 스프링의 지원 방법
  1. 인터페이스 (InitialzingBean, DisposableBean)
  2. 설정 정보에 초기화 메서드, 종료 메서드 지정
  3. @PostConstruct, @PreDestroy 애노테이션 지원 

### 인터페이스 (InitialzingBean, DisposableBean)
- 해당 인터페이스는 각각 afterPropertiesSet() , destroy() 함수를 가지고 있다. 
- 이 인터페이스를 구현한 클래스에서 적절한 처리를 해주면, 각각 콜백 시기에 맞춰 수행되는 것을 보장한다. 
- 단점 
  - 스프링 전용 인터페이스이다.
  - 초기화, 소멸 메서드의 이름을 변경할 수 없다.
  - 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다. 
- 결론적으로 해당 방법은 잘 사용하지 않는다. 

### 메서드 지정
- 설정정보에 @Bean(initMethod = "init", destroyMethod = "close") 처럼 메서드를 지정할 수 있다. 
- 종료 메서드 추론
  - @Bean의 속성인 destroyMethod은 기본값이 inferred이다. 
  - 해당 기능은 close, shutdown 라는 이름의 메서드를 자동 호출해준다. (라이브러리는 대부분 close, shutdown 이라는 종료 메서드를 사용)
  - 추론 기능을 사용하기 싫으면 destroyMethod = "" 이라고 굳이 적어주면 된다.

### 애노테이션 
- 메서드단에 @PostConstruct, @PreDestroy을 붙여준다. 
```java
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

public class NetworkClient {
    
 private String url;
 
     public NetworkClient() {
        System.out.println("생성자 호출, url = " + url);
     }
     public void setUrl(String url) {
        this.url = url;
     }
     //서비스 시작시 호출
     public void connect() {
        System.out.println("connect: " + url);
     }
     public void call(String message) {
        System.out.println("call: " + url + " message = " + message);
     }
     //서비스 종료시 호출
     public void disConnect() {
        System.out.println("close + " + url);
     }
     @PostConstruct
     public void init() {
       System.out.println("NetworkClient.init");
       connect();
       call("초기화 연결 메시지");
     }
     @PreDestroy
     public void close() {
       System.out.println("NetworkClient.close");
       disConnect();
     }
}


@Configuration
static class LifeCycleConfig {
  @Bean
  public NetworkClient networkClient() {
        NetworkClient networkClient = new NetworkClient(); 
        networkClient.setUrl("http://hello-spring.dev");
    return networkClient;
  }
}
```
- 실행결과
```java
생성자 호출, url = null                                                              // 생성, 의존관계 주입 
NetworkClient.init                                                                 // @PostConstruct
connect: http://hello-spring.dev                                            
call: http://hello-spring.dev message = 초기화 연결 메시지
19:40:50.269 [main] DEBUG 
org.springframework.context.annotation.AnnotationConfigApplicationContext - 
Closing NetworkClient.close                                                         // @PreDestroy
close + http://hello-spring.dev                                                     // disConnect()
```
- 단점 : 외부 라이브러리에는 적용 불가이므로, 이때는 @Bean의 기능을 사용하자. 


## 빈 스코프
- 빈이 존재할 수 있는 범위
  - 기본 값은 싱글톤 스코프라, 스프링 컨테이너 유지되는 동안 스프링 빈이 생성 및 유지되었다.
- 종류
  - 싱글톤 : 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위
  - 프로토타입 : 스프링 컨테이너가 빈의 생성과 의존관계 주입까지만 관여하는 매우 짧은 범위 
  - 웹 관련 
    - request : 웹 요청이 들어오고 나갈때 까지 유지
    - session : 웹 세션이 생성되고 종료될 때 까지 유지
    - application : 웹의 서블릿 컨텍스트와 같은 범위로 유지

# 03_HTTP 웹 기본 지식
- port - 같은 IP 내에서 프로세스 구분 
## HTTP (메서드)
### 속성
- 안전 : 호출해도 리소스를 변경하지 않는다.
- 멱등 : 한번 호출하든, 몇 번을 호출하든 결과가 똑같다.
  - 자동 복구 매커니즘에서, 클라이언트가 같은 요청을 다시 해도 되는지에 대한 판단 근거가 된다. 
  - 멱등한 것 : GET, PUT, DELETE
  - 아닌 것 : POST
- 캐시가능 : 응답 결과 리소스를 캐시해서 사용해도 된다.
  - GET에서만 사용한다. POST도 가능은 하지만, 본문 내용까지 캐시 키로 구현하는것이 쉽지 않음 

### 클라이언트에서 서버로 데이터 전송하는 방법
1. `GET` 정적 데이터 조회
   - 이미지, 정적 텍스트 문서
   - 쿼리 파라미터 없이 리소스 경로로 단순 조회 사용 
2. `GET` 동적 데이터 조회
  - 검색, 정렬 필터 증
  - 쿼리 파아미터 이용 
3. `Post`, `Get` HTML Form을 통한 데이터 전송
  - 회원 가입, 상품 주문, 데이터 변경
  - `<form anction = "/url" method = "post">`
    - `<input type = "text" name = "username">`
  - Get전송방식은 파일 업로드 같은 바이너리 데이터 전송시 사용 
4. HTTP API를 통한 데이터 전송
  - 회원 가입, 상품 주문, 데이터 변경
  - 서버 to 서버, 앱 클라이언트, 웹 클라이언트 (Ajax)
  - Get : 쿼리 파라미터 활용
  - Post, Put, Patch 등등 : 메시지 바디를 통해 데이터 전송 
- POST와 PUT의 차이
  - URI 인지 유무
    - `Post` 클라이언트는 등록될 리소스의 URI를 모른다. POST/members  -> 서버가 생성 POST/members/100
    - `Put` 클라이언트가 리소스 URI를 알고 있어햐 한다. PUT/files/{filename} 

### URI 설계 개념
- 문서 
  - 단일 개념 (파일 하나, 객체 인스턴스, 데이터베이스 row)
  - /memebrs/100 , /files/star.jpg
- 컬렉션 
  - 서버가 관리하는 리소스 디렉터리
  - /members
- 스토어
  - 클라이언트가 관리하는 자원 저장소 
  - 클라이언트가 리소스의 URI를 알고 관리
  - /files
- 컨트롤러, 컨트롤 URI
  - 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
  - 동사를 직접 사용
  - /members/{id}/delete

## 상태코드
- 1xx : 요청이 수신되어 처리중
- 2xx : 요청 정상 처리
- 3xx : 요청을 완료하려면 추가 행동이 필요
- 4xx : 클라이언트 오류 
- 5xx : 서버 오류

### 리다이렉션
- 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동한다.
- 종류
  - 영구 : 특정 리소스의 URI가 영구적으로 이동
    - /members -> /users
    - /event -> /new-event
    - 리다이렉션시 요청 본문을 유지하는 것과 안하는 코드가 분류됨
  - 일시 리다이렉션 : 일시적인 변경
    - 주문 완료 후 주문 내역 화면으로 이동
    - PRG : Post/Redirect/Get
    - 해당 기능으로 새로고침 이슈로 post가 두번 전송되어 중복 주문및 실행을 방지 한다. 
    - 리다이렉션시 요청 메서드가 Get으로 바뀜 유무, 본문 제거 유무에 따라 코드가 분류됨 
  - 특수 리다이렉션 : 결과 대신 캐시를 사용

## Header
- 활용 기능 : Authorization, cookie, 캐시 
- 캐시와 쿠키의 차이 
  - 캐시는 웹 페이지나 리소스의 임시 저장소로 사용되어 로딩 속도를 향상시키고 네트워크 트래픽을 줄이는 데 사용되고, 쿠키는 클라이언트와 서버 간의 상태 정보를 유지하고 사용자를 식별하는 데 사용됩니다.
### 쿠키
- 보안 사용
  - Secure
    - 쿠키는 http, https 구분하지 않고 전송
    - Secure을 적용하면 https인 경우에만 전송한다.
  - HttpOnly
    - XSS 공격방지
    - 자바스크립트에서 접근 불가 
    - HTTP 전송에만 사용
  - SameSite
    - XSRF 공격 방지
    - 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송 

### 캐시
- 데이터가 변경 되지 않는다면 데이터를 다시 다운 받지 않고 캐시에 있던것을 꺼내 쓰게 함으로써, 네트워크 비용을 줄임
- 캐시 유효 시간이 지나면, 해당 데이터의 최종 수정일을 체크하여 첫 요청 받은 시간보다 후시간대이면 다시 다운로드를 하여 Body에 담아 응답하고, 아니라면 Body 없이 응답한다.(304 Not Modified)
  - ETag를 활용하여 검증하기도 한다. 
- 프록시캐시
  - 미국과 한국의 여러 브라우저가 연결된다고 할 때, 각 한국 브라우저가 미국의 원서버까지 도달하는 시간이 오래 걸린다.
  - 이를 해결하고사 public한 캐시 서버를 한국에 만드는 것이 프록시 캐시 서버이다. 
  - 각 웹 브라우저는 private하고 이 public한 캐시 서버에 연결하여 사용 
  - 활용
    - 캐시 지시어로 프록시 캐시에서만 검증할건지, 원서버까지 올라가서 검증 후 캐시를 업데이트 한건지 판단 가능 