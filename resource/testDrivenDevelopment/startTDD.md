# 📒테스트 주도 개발 시작하기 - 최범균
- 관련 코드 : https://github.com/S2uJeong/hello-TTD

## to-do
- 7장. 대역

## 2장. TDD 시작
### 기본
- 순서 
  1. @Test 메서드 제작
    - 고민점
        - 메서드 이름
        - 파라미터 개수, 파라미터 타입, 반환 값
        - 정적/인스턴스 메서드
        - 메서드를 제공할 클래스의 이름
  2. 테스트 메서드에 따라 필요한 클래스 및 메서드를 test 폴더 아래에 생성 뒤, 테스트
  3. 테스트 성공하면 src 폴더 아래에 옮겨 배포 대상에 포함한다.
- 테스트 -> 코딩 -> (테스트 통과 후) 리팩토링  순서를 반복함 

### 테스트가 개발을 주도 한다는 것
- 개발 범위를 정해 점진적 구현 가능 
  - 테스트 작성하는 과정에서 구현을 생각 하지 않고, 기능이 올바르게 동작하는지 검증할 수 있는 코드를 만들었다.
  - 테스트 추가 뒤에는 '테스트를 통과 시킬' 만큼 기능을 구현했다. 아직 추가 하지 않은 테스트를 고려해서 구현하지 않았다.
- 지속적인 코드 정리 가능 
  - 테스트 코드가 있으면 리팩토링을 보다 과감하게 진행 가능
  - 잘 동작하는 코드를 수정하는 것은 심리적으로 불안함을 주기 때문에 해당 기능이 온전하게 동작한다는 것을 검증해주는 테스트 코드가 있으면 심리적으로 안정감 있게 리팩토링을 할 수 있다. 
- 빠른 피드백
  - 새로운 코드를 추가하거나 기존 코드를 수정하면 테스트를 돌려서 해당 코드가 올바른지 바로 확인 가능

## 3장. 테스트 코드 작성 순서 
- 쉬운 경우에서 어려운 경우로 진행
  - 복잡한 테스트 하나를 통과 시키기 위해 구현해야 할 코드가 많아진다.
  - 보통 수 분내에 구현을 완료하고 통과시킬 수 있는 테스트를 선책해야 한다. 이를 통해 점진적으로 구현을 완성해간다.
- 예외적인 경우에서 정상인 경우로 진행
  - 예외에 따른 if-else를 미리 만들면 많은 코드를 완성한 뒤에 반영할 때보다 코드 구조가 덜 바뀐다.
- 완급 조절 하기
  - 한 번에 얼마만큼의 코드를 작성할 것인가?
    1. 정해진 값을 리턴
    2. 값 비교를 이용해서 정해진 값을 리턴
    3. 다양한 테스트를 추가하면서 구현을 일반화 : 몇 차례 상수를 사용해서 테스트를 통과시키고 뒤에 구현을 일반화 하는 과정
- tip
  - 시작부터 잘 안될때는 검증하는 코드부터 작성한다.
    ```java
    @Test
    void test() {
        assertEquals(기대하는 값, 실제 값);
    }
    ```
    - 그 후 값으로 바꿔나가며 메서드를 정의하고 대입하며 작성해 간다.
  - 중간마다 리팩토링을 진행하는데, 리팩토링 범위가 넓어 시간이 많이 소요될 것 같으면 To-do로 남겨 두고 테스트 사이클을 유지하는 것이 좋다.

## 4장. TDD-기능 명세-설계 
- 설계 과정을 지원하는 TDD 
  - TDD에서는 필요할 것으로 예측해서 미리 설계를 유연하게 만들지 않는다
  - 실제 테스트 사례를 추가하고 통과시키는 과정에서 필요한 만큼 설계를 변경한다. 
- 기능 명세 구체화 역할 
  - 테스트 코드를 작성하려면 파라미터와 결과 값을 정해야 하므로 개발자는 요구사항 문서에서 기능의 입력과 결과를 도출하게 되고
  - 다양한 사례를 추가하는 과정에서 구현하기 애매한 점을 발견하게 된다.

## 5장. JUnit5 - Ver5.5
### JUnit5 모듈 구성
- JUnit 플랫폼 : 테스팅 프레임워크를 구동하기 위한 런처와 테스트 엔진을 위한 API 제공 
- JUnit 주피터 : JUnit5를 위한 테스트 API와 실행 엔진 제공
- JUnit 빈티지 : JUnit3,4에서 작성된 테스트를 JUnit5 플랫폼에서 실행하기 위한 모듈 제공
### 주요 단언 메서드
- @Test : test메서드 위에 붙여 준다. 해당 메서드는 `private`이면 안 된다. 
- Assertions 클래스가 제공하는 단언 메서드

  | 메서드                                        | 내용                             |
  | --------------------------------------------- | -------------------------------- |
  | assertEquals(expected, actual)                | 실제 값이 기대하는 값과 같은지   |
  | assertNotEquals(unexpected, actual)           | 실제 값이 특정 값과 같지 않은지  |
  | assertSame(Object expected, Object actual)    | 두 객체가 동일한 객체인지        |
  | assertNotSame(Object expected, Object actual) | 두 객체가 동일하지 않은 객체인지 |
  | assertTrue(boolean condition)                 | 값이 true인지                    |
  | assertFalse(boolean condition)                | 값이 false인지                   |
  | assertNull(Object actual)                     | 값이 null인지                    |
  | assertNotNull(Object actual)                  | 값이 null이 아닌지               |
  | fail()                                        | 테스트를 실패 처리               |
- | assertThrows(Class<T> expectedType, Executable executable) | executable을 실행한 결과로 지정한 타입의 익셉션이 발생하는지 | 
  | assertDoesNotThrows(Executable executable)                 | executable을 실행한 결과로 익셉션이 발생하지 않는지          |


### 테스트 라이프사이클 
- Jnit은 각 테스트 메서드마다 다음 순서대로 코드를 실행한다.
  1. 테스트 메서드를 포함한 객체 생성
  2. (존재하면) @BeforeEach 애노테이션이 붙은 메서드 실행
  3. @Test 애노테이션이 붙은 메서드 실행
  4. (존재하면) @AfterEach 애노테이션이 붙은 메서드 실행
- 한 클래스의 모든 테스트 메서드가 실행되기 전/후에 특정 작업을 수행해야 한다면 @BeforeAll , @AfterAll 사용 

### 테스트 메서드 간 실행 순서 의존과 필드 공유하지 않기 
- 테스트 메서드는 독립적으로 동작해야 한다.
- 의존이 생기면 테스트 코드의 유지보수를 어렵게 한다. 

## 6. 테스트 코드의 구성 
### 기능에서의 상황
- 기능은 상황에 따라 결과값이 달라 질 수 있다.
- 같은 input이여도 정의된 기능에 따라 결과값이 다른것이 상황의 골자 이다. 
- 따라서 테스트 코드를 구성할 때, 상황 - 실행 - 결과 확인 세 가지 요소로 구성하여 input 대비 output 검증을 더 정확히 할 수 있다. 
- given - when - then 
  - 야구게임 예시 
  ```java
  // 예측한 숫자가 456 (input)일 떄, 상황 : 정답 숫자 
  @Test
  void exactMatch() {
    // given : 정답이 456인 상황 
    BaseBallGame game = new BaseBallGame("456");
    // when : 실행
    Score score = game.guess("456");
    // then : 결과 확인
    assertEquals(3,score.strikes());
    assertEquals(0,score.balls());
  }
  
  @Test
  void noMatch() {
    // given : 정답이 123인 상황 
    BaseBallGame game = new BaseBallGame("123");
    // when : 실행
    Score score = game.guess("456");
    // then : 결과 확인
    assertEquals(0,score.strikes());
    assertEquals(0,score.balls());
  }
  ```
- 혹은 @BeforeEach에 상황을 설정하여 진행하기도 한다. 

## 7. 대역 
- 대역의 필요성
  - 테스트를 작성하다 보면 외부 요인이 필요한 시점이 있다.
  ```
  - 테스트 대상에서 파일 시스템을 사용
  - 테스트 대상에서 DB로부터 데이터를 조회하거나 데이터를 추가
  - 테스트 대상에서 외부의 HTTP 서버와 통신
  ```
  - 예시 
    - 외부 업체가 제공하는 API를 이용해서 카드번호가 유효한지 확인하고 그 결과에 따라 자동이체 정보를 등록하는 기능
    - 이 기능을 테스트 하려면  다양한 상황의 카드번호를 외부 업체에서 받아와야 한다. 
    - 이렇게 되면 테스트 결과의 신뢰도도 떨어진다. 테스트 데이터를 다른 업체에서 제공할 때 어떤 조건으로 확인해서 줬는지 알게 모람 


## 8. 테스트 가능한 설계
### 테스트가 어려운 설계
- 하드 코딩된 경로 
  - 테스트 환경에 따라 경로를 다르게 줄 수 있는 수단이 없어짐
- 의존 대상을 직접 생성
  - 해당 코드를 테스트 하려면 의존 대상을 올바르게 동작하는데 필요한 모든 환경을 구성해야 하기 때문
- 정적 메서드 사용 
  - 해당 메서드의 클래스가 인증 서버와 통신하는 경우 테스트 하기 위해 인증 서버가 필요하다. 
- 실행 시점에 따라 달라지는 결과 : Random(), LocalDate() 등
- 역할이 섞여 있는 코드 
- 테스트 대상이 사용하는 의존 대상 클래스나 메서드가 final이다. 이 경우 대역으로 대체가 어려울 수 있다.

### 테스트 가능한 설계 
- 하드 코딩된 상수를 생성자나 메서드 파라미터로 받기 
  - 해당 상수를 교체할 수 있는 기능 추가 하기 위해
  - 생성자나 세터를 이용해서 경로 전달 받는 것도 가능 
- 의존 대상 주입 받기 
  - 의존 대상을 교체할 수 있게 되면 실제 구현 대신에 대역을 사용할 수 있어 테스트를 원활하게 함 
- 테스트 하고 싶은 코드 별도의 메서드로 분리하기 
  - 


## Mockito 기초 사용법

 