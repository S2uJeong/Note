# 📒테스트 주도 개발 시작하기 - 최범균
- 관련 코드 : https://github.com/S2uJeong/hello-TTD

## 2장. TDD 시작
### 기본
- 순서 
  1. @Test 메서드 제작
    - 고민점
        - 메서드 이름
        - 파라미터 개수, 파라미터 타입, 반환 값
        - 정적/인스턴스 메서드
        - 메서드를 제공할 클래스의 이름
  2. 테스트 메서드에 따라 필요한 클래스 및 메서드를 test 폴더 아래에 생성 뒤, 테스트
  3. 테스트 성공하면 src 폴더 아래에 옮겨 배포 대상에 포함한다.
- 테스트 -> 코딩 -> (테스트 통과 후) 리팩토링  순서를 반복함 

### 테스트가 개발을 주도 한다는 것
- 개발 범위를 정해 점진적 구현 가능 
  - 테스트 작성하는 과정에서 구현을 생각 하지 않고, 기능이 올바르게 동작하는지 검증할 수 있는 코드를 만들었다.
  - 테스트 추가 뒤에는 '테스트를 통과 시킬' 만큼 기능을 구현했다. 아직 추가 하지 않은 테스트를 고려해서 구현하지 않았다.
- 지속적인 코드 정리 가능 
  - 테스트 코드가 있으면 리팩토링을 보다 과감하게 진행 가능
  - 잘 동작하는 코드를 수정하는 것은 심리적으로 불안함을 주기 때문에 해당 기능이 온전하게 동작한다는 것을 검증해주는 테스트 코드가 있으면 심리적으로 안정감 있게 리팩토링을 할 수 있다. 
- 빠른 피드백
  - 새로운 코드를 추가하거나 기존 코드를 수정하면 테스트를 돌려서 해당 코드가 올바른지 바로 확인 가능

## 3장. 테스트 코드 작성 순서 
- 쉬운 경우에서 어려운 경우로 진행
  - 복잡한 테스트 하나를 통과 시키기 위해 구현해야 할 코드가 많아진다.
  - 보통 수 분내에 구현을 완료하고 통과시킬 수 있는 테스트를 선책해야 한다. 이를 통해 점진적으로 구현을 완성해간다.
- 예외적인 경우에서 정상인 경우로 진행
  - 예외에 따른 if-else를 미리 만들면 많은 코드를 완성한 뒤에 반영할 때보다 코드 구조가 덜 바뀐다.
- 완급 조절 하기
  - 한 번에 얼마만큼의 코드를 작성할 것인가?
    1. 정해진 값을 리턴
    2. 값 비교를 이용해서 정해진 값을 리턴
    3. 다양한 테스트를 추가하면서 구현을 일반화 
    : 몇 차례 상수를 사용해서 테스트를 통과시키고 뒤에 구현을 일반화 하는 과정

## 4장. TDD-기능 명세-설계 
## 5장. JUnit5 - Ver5.5
### JUnit5 모듈 구성
- JUnit 플랫폼 : 테스팅 프레임워크를 구동하기 위한 런처와 테스트 엔진을 위한 API 제공 
- JUnit 주피터 : JUnit5를 위한 테스트 API와 실행 엔진 제공
- JUnit 빈티지 : JUnit3,4에서 작성된 테스트를 JUnit5 플랫폼에서 실행하기 위한 모듈 제공
### 주요 단언 메서드
- @Test : test메서드 위에 붙여 준다. 해당 메서드는 `private`이면 안 된다. 
- Assertions 클래스가 제공하는 단언 메서드

  | 메서드                                        | 내용                             |
  | --------------------------------------------- | -------------------------------- |
  | assertEquals(expected, actual)                | 실제 값이 기대하는 값과 같은지   |
  | assertNotEquals(unexpected, actual)           | 실제 값이 특정 값과 같지 않은지  |
  | assertSame(Object expected, Object actual)    | 두 객체가 동일한 객체인지        |
  | assertNotSame(Object expected, Object actual) | 두 객체가 동일하지 않은 객체인지 |
  | assertTrue(boolean condition)                 | 값이 true인지                    |
  | assertFalse(boolean condition)                | 값이 false인지                   |
  | assertNull(Object actual)                     | 값이 null인지                    |
  | assertNotNull(Object actual)                  | 값이 null이 아닌지               |
  | fail()                                        | 테스트를 실패 처리               |
- | assertThrows(Class<T> expectedType, Executable executable) | executable을 실행한 결과로 지정한 타입의 익셉션이 발생하는지 | 
  | assertDoesNotThrows(Executable executable)                 | executable을 실행한 결과로 익셉션이 발생하지 않는지          |


### 테스트 라이프사이클 
- Jnit은 각 테스트 메서드마다 다음 순서대로 코드를 실행한다.
  1. 테스트 메서드를 포함한 객체 생성
  2. (존재하면) @BeforeEach 애노테이션이 붙은 메서드 실행
  3. @Test 애노테이션이 붙은 메서드 실행
  4. (존재하면) @AfterEach 애노테이션이 붙은 메서드 실행
- 한 클래스의 모든 테스트 메서드가 실행되기 전/후에 특정 작업을 수행해야 한다면 @BeforeAll , @AfterAll 사용 

### 테스트 메서드 간 실행 순서 의존과 필드 공유하지 않기 
- 테스트 메서드는 독립적으로 동작해야 한다.
- 의존이 생기면 테스트 코드의 유지보수를 어렵게 한다. 

## 6. 테스트 코드의 구성 