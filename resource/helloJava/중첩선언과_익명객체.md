## 중첩 클래스
- 클래스 내부에 선언한 클래스 
- 클래스가 특정 클래스하고만 관계를 맺을 경우에는 중첩 클래스로 선언하는 것이 유지보수에 도움된다.
- 사용 장점
  - 클래스의 멤버를 쉽게 사용 가능
  - 외부에는 중첩 관계 클래스를 감춰 코드의 복잡성 낮춤
- 종류 : 선언하는 위치에 따라 
  1. 멤버 클래스 : 클래스 멤버로서 선언되는 중첩 클래스
    - 인스턴스 멤버 클래스 : `static`이 안 붙은 멤버 클래스로 바깥 클래스의 객체를 생성해야만 내부 클래스의 객체를 생성할 수 있다.
    - 정적 멤버 클래스 : `static`이 붙은 멤버 클래스. 바깥 클래스의 객체를 생성하지 않아도 내부 클래스 객체를 생성할 수 있다.
    ```java
    // 인스턴스
    class A {
        class B {} 
    }
    // 정적
    class A {
        static class B {}
    }
    ```
  2. 로컬 클래스 : 메소드 내부에서 선언되는 중첩 클래스 
   - 메서드가 실행될 때만 내부 클래스의 객체를 생성 할 수 있다.
  ```java
   class A {
    void method() {
        class B {} 
    } 
  }
  ```

### 1. 인스턴스 멤버 클래스
- 객체 생성 위치 
  ```java
   public class A {
      class B {}
      // 1.인스턴스 필드 값
      B field = new B();
      // 2. 생성자
      A() {
         B b = new B();   
        }
      // 3. 인스턴스 메서드
      void method() {
          B b = new B();
      }
  }
  ```
- 접근제한
  - 일반적으로 특정 클래스 내부에서만 사용해서 `private`를 갖는것이 일반적이다.
  - `public`, `default` 로 선언하여 외부에서 객체 생성이 가능하게 할 수 있지만 
     이런 경우 외부 클래스 객체를 먼저 생성한 다음, 내부 클래스 객체를 생성해야 한다.
    ```java
    A a = new A();
    A.B b = a.new B();
    
    b.method()
    ```
- 외부 클래스의 멤버 접근 권한
    - 외부 클래스의 모든 필드와 메서드 

### 2. 정적 멤버 클래스
- 객체 생성 위치
  - 내부 클래스 객체는 외부 클래스 내부 어디에서든 객체를 생성할 수 있다. = 정적 필드나 정적 메서드로 객체 생성 가능
- 접근제한
  - 내부클래스가 외부클래스와 함께 외부에서 사용되는 경우가 많아 `public`이나 `default`를 갖는것이 일반적이다.
  - 외부 클래스 이외 외부에서 내부 객체를 생성하려면 외부 클래스 생성 없이 내부 클래스의 객체를 생성할 수 있다.
      ```java
      // 인스턴스 필드 및 메서드 사용
      A.B b = new A.B();
      b.field;
      b.method;
      // 정적 필드 및 메서드 사용
      A.B.field;
      A.B.method();
      ```
- 외부 클래스의 멤버 접근 권한
  - 외부 클래스의 정적 필드와 정적 메소그 
  
### 3. 로컬 클래스
- 객체 생성 위치 
    ```java
    public class A {
        // 생성자
        public A() {
            class B {}
            B b = new B();
        }
        // 메서드
        public void method() {
            class B {}
            B b = new B();
        }
    }
   ```
- 로컬 변수를 로컬 클래스에서 사용할 셩우 로컬 변수는 final 특성을 갖게 된다. (자동적으로) => 수정 불가해짐
  - 코드를 작성할 때 발생할 수 있는 잠재적인 버그를 방지하는데 목적을 두고 만든 규칙 
  ```java
  public class A {
    public void method1(int arg) {  //final int arg
        // 로컬 변수
        int var = 1;    // final int var = 1; 이 된다.     
        // 로컬 클래스 
        class B {  
           void print() {
             // arg += 1; var += 1;   ==> 수정 불가 
             print(arg);
             print(var);
            }
         } 
        // 로컬 객체 생성
        B b = new B();
        b.print();
        // 로컬 변수 수정 불가
        // arg += 1; var +=1; 
   }
  }
  ```
### this 사용
- 중첩(내부) 클래스 내부에서 this는 해당 중첩 클래스의 객체를 의미한다.
- 외부 클래스의 객체를 얻으여면 외부 클래스 이름에 `this`를 붙여준다.
```java
this.field   // 내부에서 내부
A.thid.field  // 내부에서 외부 
```

## 중첩 인터페이스 
- 클래스 멤버로 선언된 인터페이스
```java
class A {
    [private|public] [static] interface B {
        // 1. 상수 필드
        // 2. 추상 메서드 
        // 3. 디폴트 메서드 
        // 4. 정적 메서드 
    }
}
```
- 해당 클래스와 긴밀한 관계를 맺는 구현 객체를 만들기 위해 사용
  - 안드로이드와 같은 UI 프로그램에서 이벤트를 처리할 목적으로 많이 활용
  - 예를 들어 버튼을 클릭했을 때 이벤트를 처리할 객체는 중첩 인터페이스를 구현해서 만든다. 
  - 이렇게 사용하면, 어떤 구현체이냐에 따라 같은 메서드라도 다른 동작을 수행한다. 
- 구현
  1. 외부 클래스에 내부 인터페이스 타입의 필드와 setter를 추가해서 외부에서 setter를 통해 구현 객체를 저장할 수 있게한다.
  2. 내부 인터페이스의 추상 메서드를 실행 시키는 메서드를 외부 클래스에 제작한다.
  ```java
  public class Button {
     public static interface ClickListener {
        void onClick(); }
     // 중첩 인터페이스타입 필드
     private ClickListener clickListener;
     // setter
     public void setClickListener(ClickListener clickListener) {
        this.clickListener = clickListener; 
    }
     // 인터페이스 메서드 실행시키는 메서드 (정확히는 setter로 주입된 구현체가 정의한 onClick())
    public void click() {
       this.clickListener.onClick(); 
    }
  }
  ```
  ```java
  public class ButtonExample {
    public static void main(String[] args) {
        /**
         * ok 버튼
         */
        // 버튼 객체 생성
        Button bntok = new Button();
        // 버튼 클릭 이벤트를 처리할 구현 클래스 (==로컬 클래스)
        class OkListener implements Button.ClickListener {
            @Override
            public void onClick() {
                System.out.println("ok버튼을 눌렀습니다.");
            }
        }
        // 버튼 객체에 구현 객체 주입
        bntok.setClickListener(new OkListener());
        bntok.click();
        /**
         * cancle 버튼
         */
        Button bntCancel = new Button();

        class CancelListener implements Button.ClickListener {
            @Override
            public void onClick() {
                System.out.println("취소 버튼을 눌렀습니다.");
            }
        }

        bntCancel.setClickListener(new CancelListener());
        bntCancel.click();

    }
  }
  ```