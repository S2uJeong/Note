# JVM 동작원리와 main() 함수 안밖의 차이

코드를 만들다가 문득 main() 함수 바깥에서 객체 생성 구문은 컴파일 되는데 객체의 메서드를 실행하는 것은 안되는 이유가 궁금해졌다.
```java
public class Main {
    static MyObject object = new MyObject();

    static {
        System.out.println("Static block executed");
    }

    StaticMethodClass.hello();  // 왜 이건 안돼?
    public static void main(String[] args) {
        StaticMethodClass.hello();
    }
}

class MyObject {
    public MyObject() {
        System.out.println("MyObject created");
    }
}

class StaticMethodClass {
    static void hello() {
        System.out.println("hello");
    }
}
```

기본적으로 JVM은 프로그램을 시작할 때 `public static void main(String[] args)` 시그니처를 가진 메서드를 찾은 뒤, 해당 메서드를 스택에 쌓으며 프로그램을 실행하게 된다. 
따라서 시작점인 main() 메서드가 없으면 실행 자체를 못 하게 된다.

그래서 main() 바깥에선 객체의 메서드를 실행 못 하는것 까진 이해가 되는데, 그럼 객체 생성은 new..() 명령으로 실행되는 메서드로 취급이 안되는걸까? 왜 가능한걸까

이는 클래스 본문 안에 독립 적인 실행문을 직접 쓸 수 없다는 규칙이 존재 하기 때문이다.
## 왜 허용되지 않는가?
- 코드의 실행 시점을 명확히 하기 위해서
- Java의 클래스는 선언과 실행의 흐름이 명확히 분리되어 있다.
  - 클래스 선언 : 클래스는 필드와 메서드를 정의하고, 실행할 코드의 틀을 제공
  - 코드 실행 : 실행 가능한 코드는 메서드(예: main(), static {}) 안에 있어야 합다.

## java는 이와 같은 규칙을 어떻게 걸러 내는가?
- 이는 JVM의 클래스 로딩 및 초기화 과정과 바이트코드 실행 구조를 통해 이루어 진다. 

### Java 프로그램 실행 과정
클래스 로더는 컴파일 된 클래스 파일을 동적으로 로드하고, JVM 메모리 영역인 Run time Data Areas에 배치하는 작업을 수행하며 아래와 같은 과정을 거친다. 
1. 클래스 로딩
   - JVM이 클래스를 처음 참조할 때 해당 클래스 파일 (.class)를 메모리로 로드
   - Method Area에 런타임 상수 풀과 클래스 메타 데이터 생성 
   - 클래스의 bytecode를 읽고 JVM 내부에 로드하는 단계
   - 어플리케이션에서 필요한 것만 동적으로 선별하여 적재한다. (이후 자세히 설명)
2. 클래스 연결
   - 검증 : 클래스 파일 형식이 유효한지 확인
   - 준비 : 클래스 변수(static 필드)를 기본 값으로 메모리에 할당
   - 해결 : 클래스에서 참조하는 다른 클래스, 메서드, 필드의 참조를 해결
3. 클래스 초기화 
   - static 필드가 선언된 값으로 초기화
   - static 초기화 블록 실행
   - 해당 과정에서 main() 메서드 호출 여부와 상관 없이 객체가 생성 된다. 즉, 클래스 로딩 시점에 객체 생성이나 코드 실행이 발생한다.

다시 본론으로 돌아와서, 클래스 본문에 실행문을 어떻게 금지하는지 설명하자면
클래스 로딩 단계에서는 클래스의 구조 (Method Area)에 로드하기만 하기 때문에 구조를 로드할 뿐 실행은 동작하지 않는다.
따라서 클래스 본문에 실행문이 있다면, 이를 실행하려는 시도를 JVM이 코드 구조적 오류로 간주한다. JVM은 실행문을 클래스 메타데이터의 일부로 간주하지 않기 때문이다.
JVM 내부적으로 실행 가능한 바이트코드는 메서드 안에 포함되어야 실행 가능한 명령으로 해석된다.

new 키워드를 사용한 객체 생성이 메서드 바깥에서도 실행되는 이유는 클래스 로딩 단계에서 실행 가능한 특별한 구조를 지녔기 때문이다.
Java는 클래스의 초기화 단계를 통해 객체 생성이나 실행이 가능하도록 설계되었다.  new 키워드는 JVM 초기화 메서드(<clinit>) 안에서 실행된다.


### 참고) 클래스 로더는 어떤 기준으로 필요한 클래스를 선별하는가
클래스 로딩 과정에서 로더는 필요한 클래스만을 동적으로 적재한다고 하였다.

1. 아무것도 호출 하지 않을 때
   - main() 함수를 가진 메인 클래스만이 로드 된다
2. 인스턴스 생성
   - 클래스를 인스턴스화 하면 클래스가 로드 됨. 
   - 이때, 내부 클래스가 있어도 직접 인스턴스를 생성한게 아니라면 로드 되지 않음
3. 내부 클래스 호출
   - 외부, 내부 클래스 모두 로드됨
4. static 내부 클래스 호출
   - 내부 클래스만 로드 
5. static 변수/메서드 호출
   - 인스턴스화 되지 않아도 관련 클래스가 로드 됨 
6. static final 상수 호출
   - 관련 클래스 로드 되지 않음
   - 상수는 JVM의 Method Area에 Constant Pool에 따로 저장,관리 