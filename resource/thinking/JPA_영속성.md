# JPA 영속성에 대해 알아보자

## 실제 사례
- getposts()하며 updateViewCount를 해줘야 하는데 조회라고만 생각해서 @Transactional 누락함 (단순 실수)
- find로 찾아서 영속성이 있는데도 불구하고 update하고서 save 호출함 -> 더티 체킹이 있어 불필요한 행동
### transactional을 메서드 안에 있는 함수에 따로 붙여 줬는데, 전체 적용이 되지 않음 -> 프록시  연관 있어 보였음
- https://www.notion.so/JPA-c3ee68562ef64a14bc7f6fa64710b493
- https://velog.io/@balparang/Transactional이-동작하지-않을-때는-프록시-객체를-통해-메서드를-호출했는지-확인하자-프록시-내부-호출-문제
아래와 같이 코드를 작성하면, Transactional이 제대로 동작할까?

```
void test() {        
  updatePostView();        
  System.out.println("hello");   
}      

@Transactional    
private void updatePostView() {       
   post.updatePostView();    
}
```



위와 같이 작성하면 `@Transactional`이 의도한 대로 동작하지 않습니다. `updatePostView()` 메서드에 `@Transactional` 애노테이션이 적용되어 있어도, 이 메서드가 같은 클래스 내의 `test()` 메서드에서 직접 호출되면 트랜잭션이 적용되지 않습니다. Spring의 AOP 기반 `@Transactional`은 외부에서 호출되는 경우에만 프록시를 통해 트랜잭션을 활성화하기 때문입니다.
@Transactional을 사용하면, @Transactional을 사용하는 객체를 상속하는 프록시 객체가 스프링 빈으로 등록되며, 의존관계 주입 시 스프링 컨테이너에 의해 프록시 객체가 주입된다.


## JPA 영속성 기본 
- 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유
- 엔티티 매니저는 쓰레드간 공유하지 않는다.
- JPA의 모든 데이터 변경은 트랜잭션 안에서 실행 
- `EntityManager.persist(entity)` : 엔티티 매니저를 통해 영속성에 접근한다.
  - 스프링 프레임워크 같은 컨테이너 환경에서 스프링 매니저 : 영속성 컨텍스트 = N : 1
### 엔티티의 생명주기
- 비영속 : 객체를 생성한 상태, 영속성 컨텍스트와 전혀 관계가 없음
- 영속 : 객체를 저장한 상태, em.persist(entity)
- 준영속 : 엔티티를 영속성 컨텍스트에서 분리, em.detach(entity)
- 삭제 : 객체를 삭제한 상태, em.remove(entity)
### 영속성 컨텍스트의 이점
- 1차 캐시
- 동일성 보장 : 1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 DB가 아닌 애플리케이션 차원에서 제공 
- 트랜잭션을 지원하는 쓰기 지연 : flush/commit 하는 순간 쿼리문을 보낸다. 
- 변경 감지
- 지연 로딩 
### 플러시
- 영속성 컨텍스트의 변경 내용을 DB에 반영
- 영속성 컨텍스트를 비우지 않고 변경 내용을 DB에 동기화 한다. 
- 발생 조건
  - 변경 감지
  - 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
  - 쓰기 지연 SQL 저장소의 쿼리를 DB에 전송 

## 프록시
- 지연 로딩을 위해 사용되는 가짜 객체
- 실제 엔티티 데이터가 필요할 때 영속성 컨텍스트를 통해 DB에서 데이터를 조회
### em.find() vs em.getReference()
- find() : DB를 통해 실제 엔티티 객체 조회
- gerReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
### 특징
- 프록시 객체는 처음 사용할 때 한 번만 초기화 한다.
  - 영속 상태에서 entity 필드에 접근하는 동작을 하면 프록시가 초기화 된다.
  - 초기화 후에는 실제 엔티티처럼 동작하며 캐시된 값을 사용한다. 
- 프록시 객체는 원본 엔티티에 상속 받음. 따라서 타입 체크시 주의 (==는 실패, instance of 사용)
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생 
  - 영속성 컨텍스트는 엔티티 객체를 관리하고, 데이터베이스와의 세션을 유지
  - 프록시 객체가 처음 사용될 때 지연 로딩을 통해 데이터를 로드해야 하는데, 이때 데이터베이스에 접근하기 위해 영속성 컨텍스트가 필요합니다.

## 즉시 로딩과 지연 로딩 
- 지연로딩을 사용하면 프록시로 조회한다. 
- ![img.png](image/지연로딩.png)
- 즉시로딩에서 발생하는 N+1을 방지하기 위해 가급적 지연 로딩 사용
  - @ManyToOne, @OneToOne은 기본이 즉시 로딩이므로 LAZY로 설정해주어야 한다.
  - 발생 이유 : 한쪽 테이블만 조회하고 연결된 다른 테이블은 따로 조회하며 페치 전략 충돌 
- 즉시 로딩이 필요할 땐 JPQL fetch 조인이나 엔티티 그래프 기능을 사용 
  - fetch join : 미리 두 테이블을 join하여 한꺼번에 가져오면 N+1 문제가 발생하지 암ㅎ음
    - Paging API 사용 불가, 1:N 관계가 두 개 이상인 경우 사용 불가
    - inner join 
  - @Entity Graph 
    - outer join

## 영속성 전이 : CASCADE
- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 사용 
- 개념상으론 CASCADE.remove 와 orphanRemoval=true 에서 부모객체에서 자식 객체 삭제시 동작하는 것은 같음
- orphanRemoval은 컬렉션에서 엔티티를 제거할 때 동작합니다.
- cascade.remove는 부모 엔티티가 remove 메서드로 삭제될 때 동작합니다. 
- 따라서, CascadeType.REMOVE는 부모 엔티티와 자식 엔티티가 완전히 함께 삭제되어야 하는 경우에 사용하며, orphanRemoval은 부모 엔티티는 유지하되 관계가 해제된 자식 엔티티만 삭제해야 할 때 사용