## 1부. 개요
### 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화하는데 있다.

### 두 가지 가치 - 행위와 구조 
- 행위 : 이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만든다.
- 구조 : 기계의 행위를 쉽게 변경할 수 있도록 한다. 
- 새로운 요청사향이 발생할 때마다 바로 이전의 변경사항을 적용하는 것보다 조금 더 힘들어지는데, 시스템의 형채와 요구사항의 형태가서로 맞지 않기 때문이다. 

## 2부. 프로그래밍 패러다임
- 아래 패러다임들은 코드를 작성하는 방식의 형태를 한정시킴으로써 유용한 것이 됐다. 
- 그리고 처음 소프트웨어의 핵심은 여전히 그대로다. 순차, 분기, 반복 
### 1. 구조적 프로그래밍
- 제어흐름에 대한 제약 : goto문의 금지
  - 이로써 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게되고
  - 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻한다.
  - 따라서 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고
  - 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다.
### 2. 객체지향 프로그래밍
- 다형성을 안전하고 편리하게 적용할 수 있는 매커니즘
- 플러그인 아키텍처를 적용할 수 있게 됨 , 장치독립적, 프로그램이 다른 장치에서도 동일하게 동작할 수 있도록 만드는 것
- 의존성 역전
  - 전형적인 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어흐름을 따르게 된다. 
- 의존성의 방향이 제어가 가능해지면서 업무 규칙을 포함하는 컴포넌트는 UI와 데이터베이스를 포함하는 컴포넌트에 의존하지 않는다.
  - 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대래 독립성을 보장 받음.
### 3. 함수형 프로그래밍
- 람다계산법
- 변수가 변경되지 않는다.
  - 경합 조건, 교착상태 조건, 동시 업데이트 문제가 모두 가변 변수로 인해 발생
  - 자원(프로세서, 저장공간)의 한계로 구현에 어느 정도의 타협이 필요한데, 그 중 하나는 애플리케이션 내부의 서비스를 가변/불변 컴포텉츠로 분리하는 것이다. 
   - 이벤트소싱 : 상태가 아닌 트랙잭션을 저장하는 전략. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다. 

## 3부. 설계 원칙 


---
### 와 닿는 문장
- 소프트웨어 개발자인 당신도 이해관계자임을 명심하라.
- 패러다임들은 코드를 작성하는 방식의 형태를 한정시킴으로써 유용한 것이 됐다. 