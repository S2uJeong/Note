## 1부. 개요
### 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화하는데 있다.

### 두 가지 가치 - 행위와 구조 
- 행위 : 이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만든다.
- 구조 : 기계의 행위를 쉽게 변경할 수 있도록 한다. 
- 새로운 요청사향이 발생할 때마다 바로 이전의 변경사항을 적용하는 것보다 조금 더 힘들어지는데, 시스템의 형채와 요구사항의 형태가서로 맞지 않기 때문이다. 

## 2부. 프로그래밍 패러다임
- 아래 패러다임들은 코드를 작성하는 방식의 형태를 한정시킴으로써 유용한 것이 됐다. 
- 그리고 처음 소프트웨어의 핵심은 여전히 그대로다. 순차, 분기, 반복 
### 1. 구조적 프로그래밍
- 제어흐름에 대한 제약 : goto문의 금지
  - 이로써 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게되고
  - 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻한다.
  - 따라서 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고
  - 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다.
### 2. 객체지향 프로그래밍
- 다형성을 안전하고 편리하게 적용할 수 있는 매커니즘
- 플러그인 아키텍처를 적용할 수 있게 됨 , 장치독립적, 프로그램이 다른 장치에서도 동일하게 동작할 수 있도록 만드는 것
- 의존성 역전
  - 전형적인 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어흐름을 따르게 된다. 
- 의존성의 방향이 제어가 가능해지면서 업무 규칙을 포함하는 컴포넌트는 UI와 데이터베이스를 포함하는 컴포넌트에 의존하지 않는다.
  - 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대래 독립성을 보장 받음.
### 3. 함수형 프로그래밍
- 람다계산법
- 변수가 변경되지 않는다.
  - 경합 조건, 교착상태 조건, 동시 업데이트 문제가 모두 가변 변수로 인해 발생
  - 자원(프로세서, 저장공간)의 한계로 구현에 어느 정도의 타협이 필요한데, 그 중 하나는 애플리케이션 내부의 서비스를 가변/불변 컴포텉츠로 분리하는 것이다. 
   - 이벤트소싱 : 상태가 아닌 트랙잭션을 저장하는 전략. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다. 

## 3부. 설계 원칙 - SOLID
- 기능
  - 함수와 데이터 구조를 클래스로 배치하는 방법 설명 
  - 이들 클래스를 서로 결합하는 방법 설명
- 목적
  - 변경에 유연한 소프트웨어
  - 이해하기 쉬운 
  - 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
- 구성
  - SRP (Single Responsibility Principle) `단일 책임 원칙` : 하나의 모듈은 오직 하나의 액터에 대해서만 책임져야 한다. 
  - OCP (Open-Closed Principle) `개방 폐쇄 원칙` : 기존 코드를 수정하지 않고 기능 확장이 가능해야 한다.
  - LSP (Liskov Substitution Principle) `리스코프 치환 원칙` : 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다. 
  - ISP (Interface Segregation Principle) `인터페이스 분리 원칙` : 이 원칙을 따르면 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않는다. 
  - DIP (Dependency Inversion Principle) `의존성 역전 원칙` : 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대 의존해서는 안된다.

### 단일 책임 원칙
- 단일 책임 원칙은 메서드와 클래스 수준의 원칙
- 사례
  - 우발적 중복 : 급여 애플리케이션, 서로 다른 액터가 같은 함수를 공유하고 있단 사실을 모르고 한 쪽의 요구사항에 맞춰 수정 시 문제가 생긴다.
  - 병합 : 액터가 서로 다른 기능 구현을 위해 같은 클래스를 수정하게 될 시, 병합이 발생한다. 
    - 해결책 : 데이터와 메서드를 분리 
- Facade Pattern 퍼사드 패턴 
  - 퍼사드 패턴은 소프트웨어 공학의 디자인 패턴으로 구조 패턴의 범주에 속한다. 
  - 클래스, 라이브러리 또는 API로 구성된 복잡한 시스템에 단순화된 인터페이스를 제공 
  - 주요 목표는 복잡성을 숨김으로써 하위 시스템을 더 쉽게 사용할 수 있도록 하는 더 높은 수준의 인터페이스를 제공하는 것이다. 
  - src/cleanArchitecture/srp/facade

### 개방 폐쇄 원칙 
- 사례
  - 재무보고표를 프린트할 때, 음수 금액은 빨간색으로 출력되도록 표시해왔다. 그런데 흑백 프린터로 뽑는 경우가 생겨 해당 상황에서는 음수를 괄호처리를 함으로써 표시한다.
  - 단일 책임 원칙을 적용하면, 재무데이터 검사 -> 보고서용 데이터 생성 -> 포맷팅 (컬러 or 흑백) 해당 방식으로 체계화 해서 쉽게 가능할 것 이다.
- 책임을 분리했다면 두 책임 중 하나에서 변경이 발생하더라고 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화 해야한다. 
  - 처리 과정을 클래스 단위로 분할
  - 클래스를 컴포넌트 단위로 구분
  - ![](resource/cleanArchitecture/img/개방폐쇄원칙.png)
- 컴포넌트 혹은 클래스의 관계는 단방향으로 이루어 져야 한다. 이는 변경으로부터 보호하려는 컴포넌트를 향하도록 한다. 
  - 인터페이스는 의존성 역전을 가능하게 하여 단방향을 가능하게 한다. 

### 리스코프 치환 원칙
- 공통의 조건을 잘 지켜서, 객체가 서로 치환될 수 있게 해야 확장성이 좋아진다는 것.
- 자바에서는, 상속과 인터페이스를 잘 이용하면 어느정도는 지켜질 수 있으나
- 책의 예시처럼 REST 서비스의 URL 필드 규칙을 어긴다면 확장이 어려워지기 떄문에 시스템적 치환 원칙은 일부러라도 신경을 써줘야 한다. 

### 인터페이스 분리 원칙
- 13장 컴포넌트 응집도와 관련있음
- 많은 컴포넌트와 관계가 생길수록 변경 파급도가 커진다

### 의존성 역전 원칙 
- 추상에 의존하며 구체에는 의존하지 않는 시스템
- 변경되지 않는다면 의존할 수 있다. 피하고자 하는 것은 변동성이 큰 구체적인 요소이다.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라
- 코딩 실천법
  - 변동성이 큰 구체 클래스를 참조하지 말라. 대신 추상 인터페이스를 참조하라
  - 변동성이 큰 구체 클래스로부터 파생하지 말라. 상속을 이용하는데 신중을 가해라
  - 구체 함수를 오버라이드 하지 말라. 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현
- 팩토리
  - 사실상 모든 언어에서 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 **소스 코드 의존성**이 발생
  - 이러한 문제를 해결하기 위해 추상팩토리를 이용 
  - 
---
### 와 닿는 문장
- 소프트웨어 개발자인 당신도 이해관계자임을 명심하라.
- 패러다임들은 코드를 작성하는 방식의 형태를 한정시킴으로써 유용한 것이 됐다. 